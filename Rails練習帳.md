Fatモデルの解消方法

- Fatモデルの中でモデルに跨った処理を解消できる
    - 主となるモデルを決めて、そこにコードを書く。
        - 複数ある手段の中で一番、初めに検討する方法。
        - メリット
            - モデルファイルを増やさなくて良いため、ファイル数が現状のままで良い。
        - デメリット
            - どっちが主モデルとなるのかがわかりにくい。
    - イベント型モデル
        - どのように行うのか？
            - 動作に着目して、モデルを作成する。例えば、「注文する」のように「〜する」というものに着目する。そのため、モデルの名前は動作に関係したものになる。ActiveRecordを必ず継承していなくても良い。
            - 例えば、ショッピングサイトでユーザが商品をサイトに注文したら、ショッピングサイト側の口座から金額を増やして、商品を減らす処理が必要。その際に、「発送する」というクラスを作成して、そこ口座に金額を増やす処理と商品を減らす処理をかく。
            - app/modelsディレクトリ下にクラスを作成する。
                - テーブル設計時点でイベント型テーブルを作成する。
                    - ActivreRecordが継承される。
                - モデル時点でイベント型モデルを作成する。
                    - ActivreRecordが継承されていない。
    - PORO
        - 何も継承していないクラス。モデルのようにactivemodelのようなクラスを継承していない。
        - Rails wayから外れるため、チーム内で認識合わせが必要。
        - クラス名はそのクラスが返却するオブジェクトの名前をつけること。そのようなネーミングだと今後、POROでactivemodelを継承して、モデルに変えたいという場合でもクラス名を変更しなくて良い。なぜなら、モデルのネーミングの仕方がそのようなネーミングでつけられているため。
    - サービスクラス
        - あまり使わない方が良い。
        - モデルとコントローラーの中間層的なもの。これを作成することによって、モデル層とコントローラー層などだけでなく、サービスクラス層が増えてしまう。app/serviceというディレクトリに作成する。それによって、Railsのメリットである密結合を消してしまう。
        - 密結合
            - メリット
                - 重複したコードを減らすことで高い生産性を出す。
                - コードを把握しやすい。
            - デメリット
                - 1箇所を変更した際の影響範囲が大きい。
        - サービスクラスのデメリット
            - privateメソッドに書いたものは他のコードでは使い回しが効かない。
            - 通常サービスクラスは1つのメソッドだけがpublicなメソッドになる。
            - メンバーによって、サービスクラスに対する認識が異なり、認識合わせが大変。
- Fatモデルの中でバリデーションが条件分岐して複雑になったコードの解消ができる。複数のユースケースでモデルに保存する方法が異なる場合に対応できる。
    - フォームオブジェクトについて
        - いつ使用すると良い
            - モデルでバリデーションにおいて、条件分岐が必要になった時。1つのテーブルに2つのフォームがあり、片方はテーブルだけでなく、フォームのバリデーションを兼ねている。もう片方はテーブルには不要なバリデーションであり、フォームのバリデーションとして必要なもの。その場合にフォームオブジェクトを使用するとモデルがfatにならない。
        - どのように行うのか？
            - フォームオブジェクトを作成する。app/formディレクトリにクラスを作成する。activerecordを継承していないものの、activerecordのような役割を担える。以下モジュールをincludeしている。
            - 以下を使用すればactiverecordを継承しなくてもモデルのような振る舞いができる。
                - ActiveModel::Attributesモジュール
                    - テーブルのカラムのような振る舞いができる。データ型を指定して、データ型を変換できたりする。また、バリデーションを設定することもできる。
                - ActiveModel::API
                    - バリデーションを実装できる
                    - クラス名.new(name: “hoge”)でインスタンスにデータを格納できる。初期化できる。
                    - form_withと連携できる。
        - 懸念点
            - モデルとフォームオブジェクトに同じバリデーションを実装することになり、冗長になってしまう。
        - 対応方法
            - バリデーションの共通処理であるEachValidatorクラスを継承したバリデーションクラスに実装して、そのクラスをモデルとフォームオブジェクトで呼び出す。
            - EachValidatorは単純なクラスに対して有効で、複雑なバリデーションの場合、ActiveModel::Validatorクラスを使用する。

- ビュー側に実装するべき表示処理に対するFatモデルへの対応方法
    - プレゼンテーション（デコレーター）
        - いつ使用すると良い
            - モデルから取得して、表示する処理に関わるもの。例えば、Userモデルから苗字、名前を結合して表示する場合。
            - 他のビューからは利用されたくない。特定のビューだけで使用させたい場合。また、ヘルパーのように他のメソッド名と被りがないかを気にしたくない時。
        - どのように行うのか。
            - gemのactivedecoratorをインストールして行う。

- モデル分割をすると良いタイミング
    - バリデーションやコールバックをスキップするタイミングや条件分岐するタイミング。
    - fatモデルを怖がってしまい、早期にモデル分割をすると失敗する。上記のようなコードが出現したタイミングでモデル分割を検討した方が良い。